# 一、绪论

### 1、 用户态和核心态区别

**内核态（Kernel Mode）**：运行操作系统程序，操作硬件
**用户态（User Mode）**：运行用户程序

* 内核态与用户态是操作系统的两种运行级别，当程序运行在最低特权级别时，就可以称之为运行在用户态。 **因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态**；当程序运行在0级特权级上时，就可以称之为运行在内核态。
* 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其 **需要操作系统帮助**完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）。
* 这两种状态的主要差别是
>
  - 处于用户态执行时， **进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的**
  - 处于内核态执行时， **则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的**。

### 2、异常和中断的区别

**异常（内中断）**

* 是指由于 执行了现行指令（CPU 内部事件）所引起的中断，如程序出错(非法指令、地址越界)

**中断（外中断）**

* 是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等

**通常异常会引起中断，但中断未必会是由异常引起**

### 3、系统调用

操作系统提供的用户接口之一，是由操作系统实现的所有系统调用所构成的集合，即程序接口或应用编程接口，是应用程序用系统之间的接口。

### 4、并发性和并行性

**并发性**：指两个或多个事件在同一时间间隔内发生
**并行性**：指两个或多个事件在同一时刻发生

# 二、进程管理

### 1、进程的概念

**引入原因**:

* 程序不能并发执行
* 对并发执行的程序加以 **控制**和 **描述*

**典型定义**：

* 进程是程序的一次执行（过程）
* 进程是一个程序及其数据在处理及上顺序执行时所发生的活动（动态性）
* 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和 **调度**的一个独立单位（有限环境下，引入线程后调度由线程控制）

### 2、进程和程序的区别

1. 程序是永存的；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；
2. 程序是静态的观念，进程是动态的观念；
3. 进程具有并发性，而程序没有；
4. 进程是竞争计算机资源的基本单位，程序不是。
5. 进程和程序不是一一对应的： 一个程序可对应多个进程即多个进程可执行同一程序； 一个进程可以执行一个或几个程序

### 3、 进程的组织结构

**进程的组成**

* 进程控制块（PCB）。每个进程均有一个PCB，是进程存在的唯一标识，可以刻画执行瞬间特征
* 程序段。进程中能被进程调度程序调度到CPU上执行的程序代码段
* 数据段。既可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间数据或结果数据
* 进程标识符（PID）
* 进程当前状态
* 进程队列指针
* 程序和数据地址
* 进程优先级
* 通信信息
* 家族联系。允许创建子进程时，会形成一个进程家族树。如子进程和父进程的标识
* 占有资源清单

### 4、线程的概念以及与进程的区别

**线程**：操作系统能够进行 **运算调度**的 **最小单位**。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。

**区别**

1. 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。 **线程依赖于进程而存在。**
2. **进程**在执行过程中拥有 **独立的内存单元**，而多个 **线程共享进程的内存**。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）
3. 进程是 **资源分配**的最小单位，线程是 **CPU调度**的最小单位；
4. 系统开销： 由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并 **不涉及存储器管理**方面的操作。可见， **进程切换的开销也远大于线程切换的开销**。
5. 通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，需要进程同步和互斥手段的辅助，以保证数据的一致性；线程间可以直接读写进程数据段（如全局变量）来进行通信。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预
6. **进程编程调试简单**可靠性高，但是创建销毁开销大； **线程**正相反，开销小，切换速度快，但是编程 **调试相对复杂**。
7. **进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉**
8. **进程适应于多核、多机分布；线程适用于多核**

### 5、进程的通信方式

#### 1）管道

1. **匿名管道**
  1. **匿名管道**是基于文件描述符的通信方式。实现两个进程间的通信时必须通过fork创建子进程，实现父子进程之间的通信。本质是内核的一块缓存（环形队列）。
  2. **读写规则**
        1. 管道内没有数据时，读端（read）发生阻塞，等待有效数据进行读取
            2. 管道容量被数据填满时，写端（write）发生阻塞，等待进程将数据读走再进行写入
                3. 如果所有管道写端对应的文件描述符被关闭，read返回0，但会将之前管道里的数据读完
                    4. 如果所有管道的读端对应的文件描述符被关闭，write操作会产生信号，SIGPIPE,进而导致write进程退出
                        5. 当要写入的数据量不大于管道的容量（PIPE_BUF）时，linux将保证写入的原子性
                            6. 当要写入的数据量大于管道容量(PIPE_BUF)时，linux将不再保证写入的原子性
  3. **特点**
        1. 只能进行单向通信
            2. 只能够用于血缘关系的进程之间，多用于父子之间
                3. 管道内部自带同步机制：子进程写一条，父进程读一条
                    4. 管道在进行通信的时候，对外层提供的服务叫做面向字节流的服务
                        5. 当进程退出之时，管道也随之释放，与文件保持一致
2. **命名管道**
  1. **概念**：本质上是一个管道文件，可以通过命令创建也可以通过函数创建，用户可以看到
  2. **特点**
        1. 可以进行不相干进程间的通信
            2. 命名管道是一个文件，对于文件的相关操作对其同样使用
  3. **读写规则**
        1. 对于管道文件，当前进程操作为只读时，则进行阻塞，直至有进程对其写入数据
            2. 对于管道文件，当前进程操作为只写时，则进行阻塞，直至有进程从管道中读取数据

#### 2）系统IPC：

##### 2.1）消息队列

* 消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示
* 与管道不同的是消息队列存放在内核中，只有在内核重启或者显式地删除一个消息队列时，该消息队列才会被真正的删除
* 消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息到达
**特点：*

1. 消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识.

2. 消息队列允许一个或多个进程向它写入与读取消息
3. 管道和消息队列的通信数据都是先进先出的原则。
4. 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势。
5. 消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺。
6. 目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，System V消息队列目前被大量使用。System V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。

##### 2.2）信号量semaphore

信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器，可以用来控制多个进程对共享资源的访问。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。
**特点：**

1. 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。
2. 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。
3. 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数。
4. 支持信号量组。

##### 2.3）信号signal

信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

##### 2.4）共享内存（Shared Memory）

它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等
特点：

1. 共享内存是最快的一种IPC，因为进程是直接对内存进行存取
2. 因为多个进程可以同时操作，所以需要进行同步
3. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

#### 3）套接字SOCKET：

socket也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机之间的进程通信。

### 6、进程的3个基本状态及其转换

* 就绪状态：只差CPU就可执行
* 执行状态
* 阻塞状态：暂停无法运行，不仅仅只缺少CPU，进程执行后不能再执行的状态
![](https://img-blog.csdnimg.cn/20210707213316170.png)

### <a name="7_138">;</a>  7、典型的调度算法，即相关计算

**调度算法的评价标准**

1. CPU利用率
2. 系统吞吐量：单位时间内CPU完成的作业量
3. 响应时间
4. 周转时间：通常用周转时间和带权周转时间来衡量
  - 周转时间：作业从 **提交至完成**的时间间隔，包括等待时间和执行时间
  - 平均周转时间
  - 带权周转时间
  - 平均带权周转时间

**调度算法**

* **先来先服务调度算法**
* **短作业（短进程、短线程）优先调度算法**
  - 处理器分配给最快完成的作业（或进程）
* **时间片轮转调度算法**
  - 按照程序达到时间先后次序排成一个队列
  - 选择队首进程执行一定的时间，称为时间片（常为100ms）
  - 进程用完时间片若还未完成就送到就绪队列队尾
* **优先级调度算法**
* **高响应比优先调度算法**
  - 每次进行作业调度时，先计算就绪队列中每个作业的响应比 **响应比=（作业等待时间+估计运行时间）/估计运行时间**
* **多级队列调度算法**
  - 根据进程的性质或类型，将就绪队列划分为若干个独立的队列，每个进程固定地分数一个队列。每个队列只采用一种调度算法，不用队列可以采用不同的调度算法
* **多级反馈队列调度算法**
  - 设置多个就绪队列，每个队列的优先级不同，从第一个队列开始优先级逐次递减
  - 每个队列的进程执行时间片的大小也各不相同，优先级越高，相应的时间片越短，通常以2递增递减
  - 在一个队列还按照先来先服务原则排队等待调度
  - 若时间片用完未完成，则进入下一个队列的队尾
  - 最后一个队列中使用时间片轮转调度算法

### 8、临界区和临界资源

* **临界资源**:（ **一次仅允许一个进程访问的资源**）
  - 引起不可再现性是因为临界资源没有互斥访问。 `&#x53EA;&#x80FD;&#x4E92;&#x65A5;&#x8BBF;&#x95EE;,&#x65E0;&#x6CD5;&#x5E76;&#x53D1;&#x8BBF;&#x95EE;`

多个进程需要修改某一数据,系统必须控制, **一次仅允许一个进程**完成 **读数据、修改数据**(算作一个整体)两件事以后，才允许别的进程对同一数据的读和修改操作

* **临界区**:
  - **定义**:进程访问临界资源的那段 **代码**
  - 访问临界资源(上下两个区可以保证临界区互斥访问)
    + 进入区:检查有无进程进入
    + 临界区:同一时间段只有一个进程
    + 退出区:将访问标志复位
  - **使用方式**
    + 如果可以进入, **设置临界区使用标志**(全局变量),组织其它后来的进程进入临界区
    + 后来的进程通过 **查看临界区使用标志**，知道自己不能进入临界区，就 **进入阻塞队列**，将自己阻塞
    + 当临界区内的进程使用完毕，退出临界区时，即在**"退出区"修改临界区使用标志**，并 **负责唤醒**阻塞队列中的一个进程，让其进入临界区

### 9、 抢占式和非抢占式调度

**抢占式**
一旦进程开始执行，调度就在进程从 **运行状态切换到就绪状态**以及从 **等待状态切换到就绪状态**时发生，称为抢占调度。也就是在执行过程中被打断，执行了其他程序。
**非抢占式**
一旦进程开始执行，调度将在 **进程终止**或进程从 **运行状态切换到等待状态**时进行。即进程获取资源(CPU时间)并持有它，直到进程终止或推送到等待状态，不会被中断。

### 10、同步机制应遵循的准则

* **空闲让进**:如果临界区空闲，则只要有进程申请就立即让其进入，以有效利用资源
* **忙则等待**:每次仅允许一个进程处于临界区，保证对临界资源的"互斥"访问
* **有限等待**:进程只能在临界区内逗留有限时间，不得使其他进程在临界区外陷入"死等"
* **让权等待**:进程不能进入临界区时，应立即释放处理机，以免陷入"忙等"状态,进入阻塞队列

### 11、进程同步与互斥的区别

* 互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。
* 同步： **并发进程**在执行次序上的 **协调**，以达到有效的资源共享和相互合作，使程序执行有可 **再现性**(封闭性)。同步是已经实现了互斥

### 12、 _实现进程互斥的软件方法_

1. 单标志法
2. 双标志先检查法
3. 双标志后检查法
4. Peterson算法

### 13、信号量保证进程之间的同步与互斥

**基本原理**

* 两个或多个进程可以通过传递信号进行合作，可以迫使进程在某个位置暂时停止执行（阻塞等待），直到它收到一个可以"向前推进"的信号（被唤醒）。
* 相应地，将实现信号灯作用的变量称为信号量。

### 14、常见的进程同步问题

**思路**

1. **每一个活动实体都是进程**,找到活动实体
2. 明确实体的 **活动流程**,用伪代码表示出来
3. 分析同步和互斥的关系:有哪些需要互斥访问分临界资源?哪些需要同步的关系
同步: 协作,一个在等待,一个在唤醒,并发进程; 互斥: 串行访问

#### 生产消费者问题

一个或多个生产者生产数据，并将生产的数据存入缓冲区，并有一个(也可以多个)消费者从缓冲区中取数据

数据结构:循环队列,in out指针
![](https://img-blog.csdnimg.cn/20200325090431196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMzEwMTQ1,size_16,color_FFFFFF,t_70)
**同步**:生产者不能像满缓冲区写数据,消费者不能从空缓冲区读取数据,使用资源信号量empty表示空缓冲区的数量;资源信号量full表示满缓冲区的数量

> 为什么要使用两个资源信号量
两个资源信号量更适合普遍的环境,如果是网络通信,那生产者生产的消息就是一种资源.

**互斥**:互斥进入缓冲区,用一个互斥信号量(将整个缓冲区作为一个临界资源)实现

#### <a name="_226">;</a> 实现方式

* 记录型信号量

> 互斥信号量成对出现;资源信号量交叉(两个进程协作使用资源)信号量的初始化很重要
![](https://img-blog.csdnimg.cn/20200325093229907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMzEwMTQ1,size_16,color_FFFFFF,t_70)

* AND信号量
![](https://img-blog.csdnimg.cn/20200325093241361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMzEwMTQ1,size_16,color_FFFFFF,t_70)
* 利用管程表示
![](https://img-blog.csdnimg.cn/20200325094703558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMzEwMTQ1,size_16,color_FFFFFF,t_70)

#### 哲学家进餐问题

![](https://img-blog.csdnimg.cn/20200325095008452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMzEwMTQ1,size_16,color_FFFFFF,t_70)
筷子为临界资源,且不相同,所以用一个信号量表示一只筷子
![](https://img-blog.csdnimg.cn/20200325095104120.png)

##### <a name="_238">;</a> 实现方式

* 记录型信号量
![](https://img-blog.csdnimg.cn/20200325095154944.png?)
构成死锁
解决方法:
* 只允许四个哲学家拿同一边的筷子

#### 读者-写者问题

**特点**

* 读进程可以共享同一个对象
* 写进程不可共享同一个对象

互斥:两个写进程对一个对象互斥,读写进程对一个对象互斥
同步:读者在读一个对象,写进程被阻塞(对一个文件的读写操作的优先问题)

### 15、死锁的概念及其必要条件

**定义**：如果一组进程中的 **每一个进程**都在等待仅由该组进程中的其他进程才能引发的事件，那么改组进程是死锁的
**现象**：多个进程再运行过程中因争夺资源而造成的一种僵局

**产生的必要条件**

* **互斥条件**：指进程对所分配到的资源进行排它性使用 。
* **请求和保持条件**：指进程已经保持了至少一个资源，但又提出了新的资源请求 。
* **不剥夺条件**：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
* **环路等待条件**：指在发生死锁时，必然存在一个进程——资源的环形链 。（充分条件）

### 16、 处理死锁的方法

* 预防死锁：破坏四个必要条件中的一个或多个
* 避免死锁：在资源动态分配过程中，使用某种方法去防止系统进入不安全的状态
* 检测死锁：检测死锁的发生，并确定与死锁有关的进程和资源
* 解除死锁：外力解脱。常用撤销或挂起一些进程

### 17、 银行家算法

**数据结构**

* **可利用资源向量**:m个元素的数组,每一个元素代表一类可利用的资源数目.如Available[j]=k,即有k个Rj类资源
* **最大需求矩阵**:n × m的矩阵,n个进程对m类资源的最大需求.Max[n,m]
* **分配矩阵**:n × m的矩阵,n个进程已经分配到多少m类资源.Allocation[n,m]
* **需求矩阵**:n × m的矩阵,n个进程还需要多少m类资源.Need[n,m]
* R e q u e s t i Request_i R e q u e s t i ​为Pi的请求向量
**流程图**
![](https://img-blog.csdnimg.cn/2020042017280493.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMzEwMTQ1,size_16,color_FFFFFF,t_70)

# <a name="__278">;</a> 三、 内存管理

### 1、 程序执行的完整过程

编辑——编译——链接——转入——运行

* 编译:将用户源代码编译成若干个目标模块
* 链接:将一组目标模块和所需要的库函数链接在一起,形成以一个完整的装入模块
* 装入:由装入程序将装入模块装入 **内存*

### 2、内存分配方式

### 3、内部碎片和外部碎片

### 4、段式和页式分配的区别

段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的 ；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的。
段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定
段向用户提供二维地址空间；页向用户提供的是一维地址空间
段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。
段页式
先分段、再分页

### 5、分页管理方式中的逻辑地址结构、页表、访存过程以及访存有效时间

### 6、快表和多级页表

### 7、虚拟内存

### 8、虚拟内存管理方式及其特点和区别

### 9、请求分页管理方式中的逻辑地址结构、页表结构、访存过程以及访存有效时间

### 10、常见的页面置换算法

# 4、文件管理

### 1、文件系统的层次结构

### 2、文件的逻辑结构、物理结构、文件控制块结构和目录结构

### 3、文件的3中外存分配方式

* 连续分配
* 链接分配
* 索引分配

### 4、4种文件存储空间的管理方法

### 5、磁盘的基本结构

### 6、数据查找过程

### 7、磁盘调度算法

* 先来先服务
* 最短寻道时间优先
* 扫描算法
* 循环扫描算法

# 5、设备管理

### 1、I/O设备4种控制方式

* 程序直接控制方式
* 中断控制方式
* DMA控制方式
* 通道控制方式

DMA控制方式和通道控制方式的联系和区别

### 2、I/O软件的层次结构

* 中断处理程序
* 设备驱动程序
* 设备独立性软件
* 用户层软件

### 3、缓冲区的分类与结构

### 4、设备分配和回收的过程

### 5、假脱机的原理与实现
